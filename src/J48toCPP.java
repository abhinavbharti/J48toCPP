
import weka.core.converters.ConverterUtils.DataSource;
import weka.core.Instances;
import weka.classifiers.trees.J48;

import weka.classifiers.Classifier;
import weka.classifiers.Evaluation;
import weka.core.Instances;
import weka.core.OptionHandler;
import weka.core.Utils;
import weka.filters.Filter;

import java.io.*;
import java.util.*;

public class J48toCPP {

    public static void main(String[] args) {

        if (args.length != 2) {

            System.err.println("J48toCPP <j48model> <basename>");
            System.exit(1);
        }


        try {

            Classifier cls = (Classifier) weka.core.SerializationHelper.read(args[0]);
            J48 tree = (J48) cls;

			Writer out = new FileWriter("predict_" + args[1] + ".hpp");

			J48toCPP converter = new J48toCPP(out, tree, "predict_" + args[1]);


			converter.convert();

			out.close();

        }
        catch (Exception e) {
            System.err.println("exception:" + e);
        }
    }

	public J48toCPP(Writer out, J48 tree, String basename) {

		this.out = new PrintWriter(out);
		this.tree = tree;
		this.basename = basename;
	}

    public static String join( Iterable< ? extends Object > pColl, String separator )
    {
        Iterator< ? extends Object > oIter;
        if ( pColl == null || ( !( oIter = pColl.iterator() ).hasNext() ) )
            return "";
        StringBuilder oBuilder = new StringBuilder( String.valueOf( oIter.next() ) );
        while ( oIter.hasNext() )
            oBuilder.append( separator ).append( oIter.next() );
        return oBuilder.toString();
    }


    public static List prefix( Iterable<String > pColl, String prefix )
    {
		List newVals = new ArrayList();
		for (String s: pColl) {
			newVals.add( prefix + s);
		}
		return newVals;
    }


	public void convert() throws Exception {
		this.te = tree.prefix().replaceAll("\n > ", "");


		parsetree("    ");

		out.println("#ifndef __"+basename+"_HPP");
		out.println("#define __"+basename+"_HPP");

		out.println("");
		out.println("// generated by J48toCPP");
		out.println("");
		out.println("// i found no way to reconstruct the original variable ordering");
		out.println("// "+basename+"::predict ( " + join(variables, ", ") + " )");
		out.println("#define DO_"+basename+"() "+basename+"::predict ( " + join(variables, ", ") + " )");
		out.println("");
		out.println("class " + basename+ " {");

		out.println(" public:");
		out.println("  enum decision { " + join(decisions, ", ") + " };");

		out.println("  static inline decision predict ( " + join(prefix(variables, "const double& "), ", ") + " ) {");

		out.println(dt.toString());

		out.println("  }");
		out.println("};");




		out.println("#endif // __"+basename+"_HPP");

	}


    private int pos;
    private String te;
    private PrintWriter out;
	private J48 tree;
	private String basename;
	private StringBuffer dt = new StringBuffer();
	private Set<String> variables = new HashSet<String>();
	private Set<String> decisions = new HashSet<String>();


    private void parsetree (String indent) {

        pos ++;
        String token = readToken();

        if (te.charAt(pos) == ']') {
			String decicion = prepareDecision(token);
			
			decisions.add(decicion);

            dt.append(indent +  "return " + decicion + ";\n" );
        }
        else {
            pos ++;
            String val = readToken();
			String variable = prepareCondition(token);

			variables.add(prepareDecision(variable));

            dt.append(indent + "if (" + variable + ") {\n");
            parsetree(indent + "  ");
            dt.append(indent+ "} else {\n");
            pos ++;
            parsetree(indent + "  ");
            dt.append(indent + "}\n");
            pos ++;

        }

    }

    private String readToken() {

        StringBuffer sb = new StringBuffer();
        char c;
        while (true) {
            c = te.charAt(pos);
            if (c == ']' || c =='[' || c == ',') {
                return sb.toString();
            }
            sb.append(c);
            pos ++;
        }
    }

    private String prepareCondition(String cond) {
        return cond.replace(":", "");
    }

    private String prepareDecision(String cond) {
        return cond.substring(0, cond.indexOf(' '));
    }
}